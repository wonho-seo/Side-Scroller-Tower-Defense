# 프로젝트: 언리얼 C++ 횡스크롤 타워 디펜스 – 로직 중심 프로토타입
📜 프로젝트 개요

이 프로젝트는 3~4일간 제작된 로직 중심 프로토타입으로, 횡스크롤 타워 디펜스 게임의 핵심 시스템을 언리얼 엔진 5와 C++로 구현한 결과물입니다.

최종 목표는 Until We Die와 같은 깊이 있는 게임이지만, 이번 단계의 목적은 시각적 완성도보다 재사용성과 확장성을 갖춘 아키텍처 구축에 집중하는 것이었습니다.

✨ 개발 철학

시스템 우선주의: 아트 없이 플레이스홀더만으로도 핵심 루프(자원 → 건설 → 방어)가 동작하도록 설계

빠른 구현 + 견고한 설계: 단기간 개발 속도와 향후 확장성을 모두 고려한 데이터/컴포넌트 기반 구조

C++ 중심 구현: 핵심 시스템(AI, 능력, 상호작용)을 블루프린트 의존 없이 C++로 직접 작성

🚀 구현된 주요 시스템
1. GAS 기반 능력 및 상태 관리

AttributeSet: 자원, 체력, 공격력 등 모든 수치 중앙 관리

Ability & Effect 분리: 행동(GA)과 데이터(GE)를 분리해 유연성 확보

GameplayTag 상태 관리: 예: Tower.State.Break 같은 태그로 액터 상태 전환 처리

2. 비헤이비어 트리 기반 AI

C++ 커스텀 노드: 인식(Service), 판단(Decorator), 행동(Task) 모듈화

동적 타겟팅: 주기적 탐색과 블랙보드 데이터 공유

AI ↔ GAS 연동: 판단은 BT, 실행은 GA라는 아키텍처 확립

3. 컴포넌트 기반 상호작용/건설

UPlayerInteractComponent: 상호작용 로직을 컴포넌트화해 재사용성 확보

건설 로직: BuildableAreaVolume + PlayerController + SpawnActor 흐름 완성

💡 주요 문제 해결 및 설계 결정 (Key Problem-Solving & Design Decisions)

겹친 상호작용 타겟 처리: 거리 기반 동적 선택 + 이벤트/주기 검사 하이브리드 모델

AI 구조: Pawn은 "몸", BT는 "뇌"로 역할 분리 → 같은 Pawn이라도 BT 교체로 다양한 행동 가능

체력 0 처리: 즉시 파괴 대신 State.Dead 태그 부여 → Ongoing Tag Requirements로 패시브 자동 제거

Getter/Setter: 매크로 대신 IDE 코드 생성 활용 → 디버깅과 확장성을 고려한 선택

네이밍 규칙: 엔진 사례를 참고해 UMyBTTask_Attack 같은 형식도 채택

🔮 향후 개발 계획

웨이브/소환 시스템: UDataTable + AWaveManager로 몬스터 웨이브 동적 관리

승리/패배 조건: 코어 건물 Health 기반 패배, 웨이브 클리어 기반 승리 조건

데이터 테이블 기반 스탯 관리: 타워/몬스터 스탯을 구조체+DataTable로 통합 관리

타워 관리 기능: 건설/철거/수리/업그레이드 → GameplayAbility로 일원화

📄 결론

본 프로토타입은 짧은 기간 동안에도 확장 가능한 전문 아키텍처와 로직 구현 능력을 입증했습니다. 비록 시각적 요소는 최소화되었지만, 구조적 완성도와 시스템적 깊이를 갖춘 기반을 마련했습니다.

👨‍💻 개발 후기

GAS의 AttributeSet, GameplayEffect, GameplayTag, AbilityTask 등 핵심 요소를 C++로 직접 구현하며 실전 감각을 체득

GAS와 AI BT의 연동을 통해 판단과 실행의 분리 아키텍처를 완성, 두 시스템의 시너지를 경험

복잡한 시스템도 단기간 학습·구현할 수 있는 문제 해결 능력과 성장 잠재력을 확인
