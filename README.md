# 프로젝트: 언리얼 C++ 횡스크롤 타워 디펜스: 로직 중심 프로토타입



## 📜 프로젝트 개요 (Project Overview)

이 프로젝트는 **3-4일**이라는 단기간에 걸쳐 횡스크롤 타워 디펜스 게임의 핵심 시스템을 C++로 구현한 **로직 중심의 프로토타입**입니다.

최종 목표는 "Until We Die"와 같은 깊이 있는 게임이지만, 이번 프로토타이핑의 주목표는 시각적인 완성도(Art Asset)보다 **재사용성과 확장성을 갖춘 견고한 아키텍처를 빠르게 구축**하는 데 있었습니다. 이를 통해 언리얼 엔진 5의 C++와 핵심 프레임워크에 대한 깊은 이해도를 증명하고자 했습니다.

---

## ✨ 개발 목표 및 핵심 철학 (Development Focus & Philosophy)

**"보여주기"보다 "움직이기":** 이번 단기 프로토타이핑에서는 다음 원칙에 집중했습니다.

* **시스템 우선주의 (System-First):** 아트 리소스 없이, 플레이스홀더(Placeholder)만으로도 게임의 핵심 루프(자원 획득 → 타워 건설 → 적 방어)가 완벽하게 작동하는 것을 목표로 했습니다.
* **빠른 구현과 견고한 설계의 양립:** 짧은 시간 안에 기능을 구현하면서도, 향후 대규모 프로젝트로 확장될 것을 대비하여 컴포넌트 기반, 데이터 기반의 전문적인 아키텍처를 채택했습니다.
* **C++ 중심의 핵심 로직:** 게임의 심장이 되는 모든 시스템(AI, 어빌리티, 상호작용)을 C++로 직접 작성하여 성능과 안정성을 확보했습니다.

---

## 🚀 단기간에 구현한 핵심 시스템 (Key Systems Implemented in 3-4 Days)

짧은 개발 기간 동안 다음과 같은 핵심 게임플레이 시스템의 C++ 기반을 완성했습니다.

#### 1. **게임플레이 어빌리티 시스템 (GAS) 기반 능력/상태 관리**
   - **어트리뷰트 셋(`AttributeSet`)**: 플레이어의 자원(Gold), 타워와 몬스터의 체력(Health), 공격력(AttackPower) 등 모든 수치 데이터를 중앙에서 관리하는 기반을 구축했습니다.
   - **어빌리티/이펙트 분리**: '자원 생산', '공격'과 같은 **행동(GA)**과 '데미지 적용', '비용 소모', '상태 변화' 같은 **데이터(GE)**를 명확히 분리하여, 데이터 기반의 유연한 설계를 구현했습니다.
   - **상태 관리**: `GameplayTag`를 활용하여 액터의 상태(예: `Tower.State.Break`)를 관리하고, 이 상태 변화에 따라 다른 시스템(패시브 어빌리티 등)이 유기적으로 반응하는 로직을 C++로 직접 작성했습니다.

#### 2. **비헤이비어 트리 기반 AI**
   - **모듈형 AI 설계**: **'인식'(Service), '판단'(Decorator), '행동'(Task)**의 역할을 명확히 구분하여, 각 기능을 C++ 커스텀 노드로 작성했습니다.
   - **동적 타겟팅**: AI가 주기적으로 주변을 탐색(`BoxTrace`)하여 가장 효율적인 타겟을 선정하고, 블랙보드를 통해 비헤이비어 트리의 다른 부분과 데이터를 공유하는 로직을 구현했습니다.
   - **AI-GAS 연동**: AI(비헤이비어 트리)가 내린 '판단'을 바탕으로, 몬스터의 GAS 컴포넌트에 등록된 공격 어빌리티(GA)를 실행시키는 연동 구조를 완성했습니다.

#### 3. **컴포넌트 기반 상호작용 및 건설 시스템**
   - **`UPlayerInteractComponent`**: 플레이어의 상호작용 로직을 컴포넌트화하여, 캐릭터 코드의 비대화를 막고 기능을 재사용할 수 있도록 설계했습니다.
   - **동적 건설 로직**: 플레이어가 특정 구역(`BuildableAreaVolume`)에 있을 때만 건설 명령을 내릴 수 있으며, `PlayerController`가 플레이어의 자원(`AttributeSet` 값)을 확인한 후 `SpawnActor`를 통해 타워를 동적으로 생성하는 전체 흐름을 구현했습니다.
     
## 🤔 기술적 고민 및 해결 과정 (Technical Decisions & Rationale)

이 프로토타입을 개발하며 마주친 주요 기술적 질문과 그에 대한 해결 과정입니다.

* **Q: 다수의 상호작용 객체가 겹쳤을 때의 타겟팅 방식은?**
    * **A:** `TStack`이나 `TQueue`의 순서 기반 방식이 가진 비직관적 문제를 파악하고, `TArray`에 모든 후보를 담은 뒤 **'가장 가까운 객체'**를 실시간으로 찾는 동적 타겟팅 시스템을 구현. 성능과 반응성의 균형을 위해 평소에는 이벤트 기반으로 작동하다가, 2개 이상의 객체가 겹치는 경합 시에만 주기적인 거리 검사를 활성화하는 **하이브리드 모델**을 채택하여 최적화.

* **Q: AI의 타겟 탐색 로직을 폰(Pawn)과 비헤이비어 트리(BT) 중 어디에 두어야 하는가?**
    * **A:** 폰을 '몸', BT를 '뇌'로 간주하는 아키텍처를 채택. 탐색(Perception) 로직을 **BT 서비스**에 구현하여, AI의 '판단'과 관련된 모든 기능을 BT에 중앙화함. 이를 통해 동일한 몬스터 폰 애셋을 사용하더라도, 다른 BT를 적용하여 완전히 다른 행동 패턴을 가진 AI를 만들 수 있는 **최고의 유연성**을 확보.

* **Q: 체력이 0이 된 액터의 패시브 효과를 어떻게 제거할 것인가?**
    * **A:** 액터를 즉시 파괴하는 대신, `AttributeSet`의 `PostGameplayEffectExecute`에서 체력이 0이 된 것을 감지하고 `State.Dead` 태그를 부여. 제거하고자 하는 패시브 GE에는 `Ongoing Tag Requirements` 설정을 통해 `State.Dead` 태그가 부여되면 **자동으로 제거**되도록 설정하여, 데이터 기반의 유연한 상태 관리 시스템을 구축.

* **Q: `Getter/Setter`의 반복적인 코드 작성을 줄일 방법은?**
    * **A:** GAS의 `ATTRIBUTE_ACCESSORS_Basic`와 같은 커스텀 매크로 제작을 고려했으나, **IDE의 코드 생성 기능을 활용하고 직접 작성하는 방식을 채택**. 이유는 커스텀 매크로가 코드의 명확성을 해치고 디버깅을 어렵게 만들며, 향후 유효성 검사 로직 추가 등의 확장성을 저해한다고 판단. 단기적인 타이핑 편의성보다 **장기적인 코드의 가독성과 유지보수성**을 우선시하는 표준적인 C++ 개발 방식을 따름.

* **Q: 작성한 C++ 클래스가 파스칼 케이스가 대채적이나 _를 쓰는경우가있는데 이건 왜 다르게 작성했는가?**
    * **A:** `언리얼 엔진의 공식 스타일 가이드는 UMyBTTaskAttack과 같은 파스칼 케이스를 권장하지만, 엔진 코드 내에서 UBTTask_BlackboardBase처럼 언더스코어(_)를 사용하여 가독성을 높이는 사례들을 발견했습니다. 이에 엔진 코드와의 일관성을 유지하고 클래스의 기본 타입과 역할을 명확히 구분하기 위해 UMyBTTask_Attack 과 같은 네이밍을 채택했습니다. 

네, 좋습니다. 단기간에 핵심 기능을 구현한 뒤, 앞으로 나아갈 방향을 명확히 정의하고 현재 구조의 개선점을 파악하는 것은 매우 훌륭한 다음 단계입니다.

이 내용을 정리해서 README에 "향후 개발 계획 및 리팩토링 로드맵" 섹션으로 추가하면, 이 프로젝트가 일회성 프로토타입이 아니라 장기적인 비전을 가진 프로젝트임을 어필할 수 있습니다.

## 🚀 향후 개발 계획 및 리팩토링 로드맵
이 프로토타입은 핵심 시스템의 가능성을 증명했으며, 아래와 같은 계획을 통해 더 완전한 게임으로 발전시킬 수 있습니다.

1. 새로운 기능 구현 로드맵
① 웨이브 및 몬스터 소환 시스템

구현 목표: 정해진 시간과 경로에 따라 몬스터 웨이브를 동적으로 소환하는 AWaveManager 액터를 구현합니다.

세부 계획: 몬스터의 종류, 수, 등장 간격 등의 웨이브 정보를 담는 UDataTable을 생성하고, AWaveManager가 이 테이블을 읽어 타이머(FTimerManager)를 통해 몬스터를 SpawnActor 하도록 설계합니다.

② 게임 종료 조건

구현 목표: 명확한 승리/패배 조건을 구현합니다.

세부 계획: AGameMode 또는 AGameState에서 게임의 전체 상태를 관리합니다. 플레이어가 지켜야 할 '코어' 건물을 만들고, 이 건물의 Health 어트리뷰트가 0이 되면 패배하도록 PostGameplayEffectExecute와 연동합니다. 특정 웨이브를 모두 막아내면 승리하는 조건을 추가합니다.

③ 데이터 테이블 기반 능력치 관리

구현 목표: 모든 타워와 몬스터의 스탯(체력, 공격력, 비용 등)을 C++이나 블루프린트에 하드코딩하는 대신, 데이터 테이블에서 중앙 관리하도록 변경합니다.

세부 계획: 타워 스탯을 담는 FStruct를 C++로 정의하고, 이 구조체를 기반으로 UDataTable 애셋을 생성합니다. 타워가 생성될 때, 자신의 ID에 맞는 행을 데이터 테이블에서 찾아 그 값을 기반으로 초기화 GameplayEffect를 동적으로 생성하여 적용하도록 시스템을 개선합니다.

④ 타워 관리 기능 (철거 및 수리)

구현 목표: 플레이어가 설치한 타워를 철거하여 자원 일부를 회수하거나, 손상된 타워를 수리하는 기능을 추가합니다.

세부 계획: '생성'을 단순한 구현에서 GameplayAbility를 통해 실행하도록 변경하며 '철거'와 '수리'를 별도의 GameplayAbility로 구현합니다.

## 📄 결론 (Conclusion)

이 프로토타입은 단 며칠의 시간만으로도 언리얼 엔진의 C++ 프레임워크를 깊이 있게 활용하여, 복잡한 게임의 핵심 로직을 얼마나 빠르고 견고하게 구축할 수 있는지를 보여줍니다. 시각적인 요소가 없음에도 불구하고, 그 이면에는 확장과 협업을 고려한 전문적인 아키텍처가 설계되어 있습니다.

## 👨‍💻 개발 후기 및 배운 점 (Retrospective & Lessons Learned)

이 프로젝트는 3-4일이라는 짧은 시간 안에 게임의 핵심 기능을 구현하는 것뿐만 아니라, 저의 기술적 성장을 위한 중요한 도전이었습니다.

프로젝트 시작 당시, 언리얼의 **게임플레이 어빌리티 시스템(GAS)**에 대한 이론적 지식은 있었지만 실제 프로젝트에 깊이 있게 적용해 본 경험은 부족했습니다. 저는 이번 단기 프로토타이핑을 **GAS의 심층적인 학습과 실전 적용을 위한 기회**로 삼았습니다.

짧은 기간 동안, `AttributeSet`의 데이터 관리부터 `GameplayEffect`의 동적인 능력치 변경, `GameplayTag`를 이용한 정교한 상태 관리, 그리고 `UAbilityTask`를 활용한 비동기 로직 루프에 이르기까지 GAS의 핵심 요소를 모두 C++로 직접 구현하며 시스템의 작동 원리를 체득할 수 있었습니다.

나아가, 단순히 GAS를 사용하는 것을 넘어 AI의 **비헤이비어 트리와 연동**하여 '판단은 AI, 실행은 GAS'라는 명확한 역할 분담 아키텍처를 성공적으로 구축하며 두 시스템 간의 시너지를 직접 경험했습니다.

이 프로젝트는 저의 GAS 활용 능력을 끌어올리는 중요한 전환점이 되었습니다. 복잡한 시스템을 두려워하지 않고, 적극적으로 학습하여 단기간에 핵심 기능을 구현해내는 저의 문제 해결 능력과 성장 잠재력을 이 프로토타입을 통해 보여드리고 싶습니다.
